### 웹의 동적 기능

- 사용자와 상호작용하며 실시간으로 데이터를 처리하고 콘텐츠를 변경할 수 있는 웹사이트의 특징.
- 웹사이트가 정적(static)인 경우에는 고정된 콘텐츠를 표시하지만, 동적(dynamic) 웹사이트는 사용자 입력, 서버 데이터, 또는 기타 조건에 따라 콘텐츠가 변경될 수 있음.

1. 서버 사이드 처리

- 기술 : PHP, Python(Django/Flask), Node.js, Java(Spring), Ruby 등
- 설명 : 서버에서 요청을 처리하고, 데이터베이스와 상호작용하여 동적으로 웹페이지를 생성
- 예시 : 로그인 시스템, 게시판, 온라인 쇼핑몰에서 상품 목록을 불러오는 기능

2. 클라이언트 사이드 처리

- 기술 : JavaScript, 프레임워크(Vue.js, React, Angular)
- 설명 : 사용자의 브라우저에서 실행되어 동적으로 페이지를 업데이트 함. 서버와의 통신 없이도 화면 일부를 변경할 수 있음.

3. AJAX(Asynchronous JavaScript and XML)

- 설명 : 웹페이지를 새로고침하지 않고 서버와 데이터를 주고받아 콘텐츠를 업데이트할 수 있음.
- 예시 : 실시간 댓글 작성, 무한 스크롤, 비동기 데이터 로딩

### 스크립트 언어

- 주로 인터프리터를 통해 실행되는 프로그래밍 언어로, 비교적 간단하고 빠르게 코드를 작성하고 실행할 수 있다는 특징이 있음. 컴파일이 필요하지 않고 소스 코드가 실행 시점에 해석되기 때문에 개발 및 수정이 용이함.
- 스크립트 언어는 개발 속도가 빠르고 유연하지만, 성능이 중요한 경우 컴파일 언어를 사용하는 것이 좋음

### 블록 스코프

- 블록 스코프는 중괄호 {}로 둘러싸인 코드 블록 내에서만 변수가 유효하게 작동하도록 하는 개념임. 즉, 블록 안에서 선언된 변수는 블록 바깥에서 접근할 수 없음.

### DOM(The Document Object Model)

- 웹 페이지(Document)를 구조화된 객체로 제공하여 프로그래밍 언어가 페이지 구조에 접근할 수 있는 방법을 제공
- 문서 구조, 스타일, 내용 등을 변경할 수 있도록 함

### DOM API

- 다른 프로그래밍 언어가 웹 페이지에 접근 및 조작 할 수 있도록 페이지 요소들을 객체 형태로 제공하며 이에 따른 메서드 또한 제공

### DOM 핵심

- 문서의 요소들을 객체로 제공하여 다른 프로그래밍 언어에서 접근하고 조작할 수 있는 방법을 제공하는 API

### DOM과 Node의 개념

1. DOM(Document Object Model)

- 웹 문서를 구조화하고, 이 구조를 프로그래밍적으로 조작할 수 있게 해주는 모델
- 웹페이지의 각 요소(텍스트, 이미지, 태그 등)가 트리 구조로 표현됨

2. Node(노드)

- DOM을 구성하는 기본 단위
- HTML 문서의 각 구성 요소(태그, 텍스트, 주석 등)가 모두 노드로 표현

### Node의 종류

1. Element Node(요소 노드)

- HTML 태그를 나타냄
- `<div>`, `<p>`, `<span>` 등

2. Text Node(텍스트 노드)

- HTML 요소 안에 있는 텍스트
- `<p>Hello World</p>`에서 "Hello World"

3. Comment Node(주석 노드)

- HTML 주석을 나타냄
- `<!-- This is a comment -->`

4. Document Node

- 전체 문서를 나타냄

### NodeList

- DOM 메서드를 사용해 선택한 Node의 목록
- 배열과 유사한 구조를 가짐
- Index로만 각 항목에 접근 가능
- JavaScript의 배열 메서드 사용 가능
- querySelectorAll()에 의해 반환되는 NodeList는 DOM의 변경사항을 실시간으로 반영하지 않음

### Element

- Node의 하위 유형
- Element는 DOM 트리에서 HTML 요소를 나타내는 특별한 유형의 Node
- 예를 들어, `<p>, <div>, <span>, <body>` 등의 HTML 태그들이 Element 노드를 생성
- Node의 속성과 메서드를 모두 가지고 있으며 추가적으로 요소 특화된 기능(예 : className, innerHTML, id 등)을 가지고 있음
- 모든 Element는 Node이지만, 모든 Node가 Element인 것은 아님

### 데이터 타입

1. 원시 자료형(Primitive Type)

- Number, String, Boolean, null, undefined
- 변수에 값이 직접 저장되는 자료형(불변, 값이 복사)

2. 참조 자료형(Reference Type)

- 객체의 주소가 저장되는 자료형(가변, 주소가 복사)

### Template Literals(템플릿 리터럴)

- 내장된 표현식을 허용하는 문자열 작성 방식
- Backtic(``)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고, JavaScript의 변수를 문자열 안에 바로 연결할 수 있음
- 표현식은 '$'와 중괄호({expression})로 표기

### null과 undefined

1. null

- 프로그래머가 의도적으로 '값이 없음'을 나타낼 때 사용

2. undefined

- 시스템이나 JavaScript 엔진이 '값이 할당되지 않음'을 나타낼 때 사용

### 동등 연산자(==)와 일치 연산자(===)

1. 동등 연산자(==)

- '암묵적 타입 변환' 통해 타입을 일치시킨 후 같은 값인지 비교

2. 일치 연산자(===)

- 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환
- `일치 연산자 사용 권장`

### 함수 선언식(function declaration) vs. 함수 표현식(function expression)

1. 함수 선언식(function declaration)

- 호이스팅 됨
- 코드의 구조와 가독성 면에서는 표현식에 비해 장점이 있음

2. 함수 표현식(function expression)

- 호이스팅 되지 않음
  - 변수 선언만 호이스팅되고, 함수 할당은 실행 시점에 이루어짐
- 함수 이름이 없는 '익명 함수'를 사용할 수 있음

- 함수 표현식 사용을 권장하는 이유
  - 예측 가능성 : 호이스팅의 영향을 받지 않아 코드의 실행 흐름을 더 명확하게 예측할 수 있음
  - 유연성 : 변수에 할당되므로 함수를 값으로 다루기 쉬움
  - 스코프 관리 : 블록 스코프를 가지는 let이나 const와 함께 사용하여 더 엄격한 스코프 관리가 가능

### JavaScript 'this' 정리

- JavaScript의 함수는 호출될 때 this를 암묵적으로 전달 받음
- JavaScript에서 this는 함수가 '호출되는 방식'에 따라 결정되는 현재 객체를 나타냄
- Python의 self와 Java의 this가 선언 시 이미 값이 정해지는 것에 비해 JavaScript의 this는 함수가 호출되기 전까지 값이 할당되지 않고 호출 시에 결정됨(동적 할당)
- this가 미리 정해지지 않고 호출 방식에 의해 결정되는 것은 함수(메서드)를 하나만 만들어 여러 객체에서 재사용할 수 있다는 장점이 있지만, 이런 유연함이 실수로 이어질 수 있다는 단점도 있음

### JSON

- JavaScript Object Notation
- Key-Value 형태로 이루어진 자료 표기법
- JavaScript의 Object와 유사한 구조를 가지고 있지만 JSON은 형식이 있는 "문자열"
- JavaScript에서 JSON을 사용하기 위해서는 Object 자료형으로 변경해야 함
- 직렬화 : `JSON.stringify()`, 역직렬화 : `JSON.parse()`

### 클래스

- 객체를 생성하기 위한 템플릿
- 객체의 속성, 메서드를 정의하는 청사진 역할

### 'new' 연산자

- 클래스나 생성자 함수를 사용하여 새로운 객체를 생성
- 클래스의 constructor()는 new 연산자에 의해 자동으로 호출되며 특별한 절차 없이 객체를 초기화 할 수 있음
- new 없이 클래스를 호출하면 TypeError 발생

### Object

- 키로 구분된 데이터 집합(data collection)을 저장하는 자료형
- 이제는 순서가 있는 collection이 필요

### Array

- 순서가 있는 데이터 집합을 저장하는 자료구조
- 대괄호([])를 이용해 작성
- 요소의 자료형은 제약 없음
- length 속성을 사용해 배열에 담긴 요소 개수 확인 가능
- push : 배열 끝 요소를 추가
- pop : 배열 끝 요소를 제거
- unshift : 배열 앞 요소를 추가
- shift : 배열 앞 요소를 제거

### 콜백 함수(Callback function)

- 다른 함수에 인자로 전달되는 함수
- 외부 함수 내에서 호출되어 일종의 루틴이나 특정 작업을 진행
- forEach
  - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
  - 반환 값 없음
- map
  - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
  - 함수 호출 결과를 모아 새로운 배열을 반환

### event

- 무언가 일어났다는 신호, 사건
- 모든 DOM 요소는 이러한 event를 만들어냄
- mouse, input, keyboard, touch...
- DOM 요소에서 event가 발생하면, 해당 event는 연결된 이벤트 처리기(event handler)에 의해 처리 됨

### event handler

- 특정 이벤트가 발생했을 때 실행되는 함수
- 사용자의 행동에 어떻게 반응할지를 JavaScript 코드로 표현한 것
- .addEventListener()
  - 대표적인 이벤트 핸들러 중 하나
  - 특정 이벤트를 DOM 요소가 수신할 때마다 콜백 함수를 호출

### 버블링(Bubbling)

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작하는 현상
- 가장 최상단의 조상 요소(document)를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작
- 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 것이 마치 물속 거품과 닮았기 때문
- 최하위의 <p>요소를 클릭하면 p -> div -> form 순서로 3개의 이벤트 핸들러가 모두 순차적으로 동작했던 것

### 이벤트가 정확히 어디서 발생했는지 접근할 수 있는 방법

- event.currentTarget
  - 현재 요소
  - 항상 이벤트 핸들러가 연결된 요소만을 참조하는 속성
  - 'this'와 같음
- event.target => 중요!
  - 이벤트가 발생한 가장 안쪽의 요소(target)를 참조하는 속성
  - 실제 이벤트가 시작된 요소
  - 버블링이 진행되어도 변하지 않음

### Synchronous(동기)

- 프로그램의 실행 흐름이 순차적으로 진행
- 하나의 작업이 완료된 후에 다음 작업이 실행되는 방식

### Asynchronous(비동기)

- 특정 작업의 실행이 완료될 때까지 기다리지 않고 다음 작업을 즉시 실행하는 방식
- 작업의 완료 여부를 신경 쓰지 않고 동시에 다른 작업들을 수행할 수 있음
- 병렬적 수행
- 당장 처리를 완료할 수 없고 시간이 필요한 작업들은 백그라운드에서 실행되며 빨리 완료되는 작업부터 처리

### Thread

- 작업을 처리할 때 실제로 작업을 수행하는 주체로, multi-thread라면 업무를 수행할 수 있는 주체가 여러 개라는 의미

### JavaScript는 Single Thread 언어임

- JavaScript는 한 번에 하나의 일만 수행할 수 있는 Single Thread 언어로 동시에 여러 작업을 처리할 수 없음
- 즉, JavaScript는 하나의 작업을 요청한 순서대로 처리할 수 밖에 없음
- 그러면 어떻게 Single Thread인 JavaScript가 비동기 처리를 할 수 있을까?

### JavaScript Runtime

- JavaScript가 동작할 수 있는 환경(Runtime)
  - 브라우저 또는 Node.js
- JavaScript는 Single Thread이므로 비동기 처리를 할 수 있도록 도와주는 환경이 필요

### 브라우저 환경에서의 JavaScript 비동기 처리 동작 방식

- 모든 작업은 Call Stack(LIFO)으로 들어간 후 처리된다.
- 오래 걸리는 작업이 Call Stack으로 들어오면 Web API로 보내 별도로 처리하도록 한다.
- Web API에서 처리가 끝난 작업들은 곧바로 Call Stack으로 들어가지 못하고 Task Queue(FIFO)에 순서대로 들어간다.
- Event Loop가 Call Stack이 비어 있는 것을 계속 체크하고 Call Stack이 빈다면 Task Queue에서 가장 오래된(가장먼저 처리되어 들어온) 작업을 Call Stack으로 보낸다.

### 비동기 처리 동작 요소

1. Call Stack

- 요청이 들어올 때 마다 순차적으로 처리하는 Stack(LIFO)
- 기본적인 JavaScript의 Single Thread 작업 처리

2. Web API

- JavaScript 엔진이 아닌 브라우저에서 제공하는 runtime 환경
- 시간이 소요되는 작업을 처리(setTimeout, DOM Event, 비동기 요청)

3. Task Queue(Callback Queue)

- 비동기 처리된 Callback 함수가 대기하는 Queue(FIFO)

4. Event Loop

- 태스크(작업)가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없는 경우엔 잠드는, 끊임없이 돌아가는 자바스크립트 내 루프
- Call Stack과 Task Queue를 지속적으로 모니터링
- Call Stack이 비어 있는지 확인 후 비어 있다면 Task Queue에서 대기 중인 오래된 작업을 Call Stack으로 Push

### Ajax(Asynchronous JavaScript and XML)

- 비동기적인 웹 애플리케이션 개발을 위한 기술
- XMLHttpRequest 기술을 사용해 복잡하고 동적인 웹 페이지를 구성하는 프로그래밍 방식
- 브라우저와 서버 간의 데이터를 비동기적으로 교환하는 기술
- Ajax를 사용하면 페이지 전체를 새로고침 하지 않아도 동적으로 데이터를 불러와 화면을 갱신할 수 있음
- Ajax의 'x'는 XML이라는 데이터 타입을 의미하긴 하지만, 요즘은 더 가벼운 용량과 JavaScript의 일부라는 장점 때문에 JSON을 많이 사용

### Ajax 목적

1. 비동기 통신

- 웹 페이지 전체를 새로고침하지 않고 서버와 데이터를 주고받을 수 있음

2. 부분 업데이트

- 전체 페이지가 다시 로드되지 않고 HTML 페이지 일부 DOM만 업데이트
- 페이지의 일부분만 동적으로 갱신할 수 있어 사용자 경험이 향상

3. 서버 부하 감소

- 필요한 데이터만 요청하므로 서버의 부하를 줄일 수 있음

### XMLHttpRequest 객체(XHR)

- 웹 브라우저와 서버 간의 비동기 통신을 가능하게 하는 JavaScript 객체

### Axios

- 브라우저와 Node.js에서 사용할 수 있는 HTTP 클라이언트 라이브러리
- 클라이언트 및 서버 사이에 HTTP 요청을 만들고 응답을 처리하는 데 사용되는 자바스크립트 라이브러리
- 서버와의 HTTP 요청과 응답을 간편하게 처리할 수 있도록 도와주는 도구
- 브라우저를 위한 XHR 객체 생성
- 간편한 API를 제공하며, Promise 기반의 비동기 요청을 처리
- 주로 웹 애플리케이션에서 서버와 통실할 때 사용

### Ajax와 Axios정리

- Ajax는 개념이자 접근 방식이며, Axios는 이를 실현하는 구체적인 도구
- Axios는 Ajax를 구현하는 도구 중 하나로, XMLHttpRequest를 추상화하여 더 사용하기 쉽게 만든 라이브러리

### 비동기 처리의 특성과 관리

1. 비동기 처리의 특성

- 비동기 처리의 핵심은 작업이 시작되는 순서가 아니라 완료되는 순서에 따라 처리된다는 것

2. 비동기 처리의 어려움

- 개발자 입장에서 코드의 실행 순서가 불명확하다는 단점 존재
- 이로 인해 실행 결과를 정확히 예측하며 코드를 작성하기 어려울 수 있음

### 비동기 처리 관리 방법

1. 비동기 콜백

- 비동기 작업이 완료된 후 실행될 함수를 미리 정의

2. Promise

- 비동기 작업의 최종 완료 또는 실패를 나타내는 객체

### 비동기 콜백

- 비동기적으로 처리되는 작업이 완료되었을 때 실행되는 함수
- 연쇄적으로 발생하는 비동기 작업을 순차적으로 동작할 수 있게 함
- 작업의 순서와 동작을 제어하거나 결과를 처리하는 데 사용

### 비동기 콜백의 한계

- 비동기 콜백 함수는 보통 어떤 기능의 실행 결과를 받아서 다른 기능을 수행하기 위해 많이 사용됨
- 이 과정을 작성하다 보면 비슷한 패턴이 계속 발생
  - "콜백 지옥" 발생 -> 지옥에 빠지지 않는 다른 표기 형태가 필요하다!

### Promise

- JavaScript에서 비동기 작업의 결과를 나타내는 객체
- 비동기 작업이 완료되었을 때 결과 값을 반환하거나 실패 시 에러를 처리할 수 있는 기능을 제공

### Promise object

- 자바스크립트에서 비동기 작업을 처리하기 위한 객체
- 비동기 작업의 성공 또는 실패와 관련된 결과나 값을 나타냄
- 콜백 지옥 문제를 해결하기 위해 등장한 비동기 처리를 위한 객체
- "작업이 끝나면 실행 시켜 줄게"라는 약속
- Promise 기반의 HTTP 클라이언트 라이브러리가 바로 Axios

### then & catch의 chaining

- axios로 처리한 비동기 로직은 항상 promise 객체를 반환
- 즉, then과 catch는 모두 항상 promise 객체를 반환
  - 계속해서 `chaining`을 할 수 있음
- then을 계속 이어 나가면서 작성할 수 있게 됨

### Promise가 제공하는 이점

1. 실행 순서의 보장

- 콜백 함수 : JavaScript의 Event Loop가 현재 실행 중인 Call Stack을 완료하기 전에는 호출되지 않음
- Promise : then/catch 메서드의 콜백함수는 Event Queue에 배치되는 순서대로 엄격하게 호출됨
- 이는 비동기 작업의 실행 순서를 더 예측 가능하게 만듦

2. 유연한 비동기 처리

- Promise는 비동기 작업이 완료된 후에도 then 메서드를 통해 콜백을 추가할 수 있음

3. 체이닝(Chaining)을 통한 연속적인 비동기 처리

- then 메서드를 여러 번 연결하여 여러 개의 콜백 함수를 순차적으로 실행할 수 있음
- 각 콜백은 주어진 순서대로 실행되며, 이전 Promise의 결과를 다음 then에서 사용할 수 있음
- 복잡한 비동기 로직을 명확하게 표현할 수 있음

4. 에러 처리의 일원화

- catch 메서드를 통해 Promise 체인 전체의 에러를 한 곳에서 처리할 수 있음
- 전통적인 콜백 방식에서 각 콜백마다 에러 처리를 해야 하는 번거로움을 해소

- Promise는 비동기 프로그래밍의 복잡성을 줄이고, 코드의 가독성과 유지보수성을 높이는 강력한 도구
- 실행 순서 보장, 체이닝, 에러 처리 등의 특징을 통해 콜백 지옥을 피하고 더 체계적인 비동기 코드 작성을 가능하게 함

### 비동기 처리가 사용자 경험에 미치는 영향

1. 동기식 처리의 한계

- 큰 데이터를 불러오는 작업을 동기식으로 처리할 경우, 데이터 로딩이 완료될 때까지 전체 앱의 실행이 차단됨
- 이로 인해 사용자는 앱이 멈추거나 응답하지 않는 것처럼 느낄 수 있음
- 특정 작업이 완료될 때까지 다른 모든 작업이 대기해야 하므로, 전반적인 앱의 반응성이 저하됨

2. 비동기 처리의 장점

- 시간이 오래 걸리는 작업(예 : 데이터 로딩, API 호출)을 백그라운드에서 처리할 수 있음
- 주요 실행 흐름이 차단되지 않아 사용자 인터페이스가 계속 반응할 수 있음
- 데이터나 작업 결과가 준비되는 대로 순차적으로 화면에 표시할 수 있어, 사용자에게 진행 상황을 보여줄 수 있음

3. 사용자 경험 향상

- 비동기 처리를 통해 앱이 더 빠르고 반응적으로 느껴지게 할 수 있음
- 로딩 인디케이터나 부분적 콘텐츠 업데이트를 통해 사용자에게 진행 상황을 알려줄 수 있음
- 사용자는 전체 데이터가 로드되기를 기다리지 않고도 앱의 일부 기능을 사용할 수 있음
